### 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

示例1：

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

示例2：

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

这里需要注意的是，这里`9+1`需要进位，也就是说`[9]`+1后，返回数组为`[1, 0]`

LeetCode题目链接：[66. 加一](https://leetcode-cn.com/problems/plus-one/)

处理起来非常的简单

- 数组从后循环，最后一位+1
- 最后一位+1后对齐除10取余，判断是否不等于0，如果不等于0，说明不需要进位，直接返回改变后的数组，如果等于0，说明有进位，继续循环，操作同上
- 如果数组循环完，一直都有进位，例如`[9, 9, 9, 9]`，+1后数组为`[1, 0, 0, 0, 0]`，说明数组除了第一位是1，剩余的都是0，且数组长度比原数组长度大1。这里我们只需要做一下简单的处理就可以了

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
let plusOne = function (digits) {
  // 从后循环
  for (let i = digits.length - 1; i >= 0; i--) {
    // 最后一位数+1
    digits[i]++
    // 最后一位数取余，如果为0，说明最后一位为9，需要进位
    digits[i] %= 10
    // 如果当前为不0，说明不需要进位，直接数字
    if (digits[i] !== 0) return digits
  }
  // 如果循环完，都在进位，初始化一个当前数组长度+1的数组，并把每一项重置为0
  digits = [...new Array(digits.length + 1)].map(() => 0)
  // 第一位设置为1
  digits[0] = 1
  return digits
};
```


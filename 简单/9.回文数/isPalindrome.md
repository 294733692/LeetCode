### 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

直观上来看回文，感觉上就是从中间对半折看是否能够一一对应

所有这个解法的操作就是 <b>取出后半段数字进行反转</b>

但是这里需要注意的是，输入的回文数字长度可奇可偶，所有当它长度是偶数时，它对折过来应该是相等的；当它的长度为奇数，那么它对折过来，有一个的长度需要去掉一位数（除以10并取整）

具体思路如下

- 特殊情况
  - 如果输入数字为负数，那么肯定不是回文，如`-1`，反转过来就是`1-`，当然`-0`，反转过来是`0-`，因为javascript输入`-0`的时候，会直接将`-0`转化为`0`
  - 同样的，如果输入数字末尾是0，那么为了使数字为回文，那么第一位也应该是0，满足这个条件的只有0

- 每次进行取余操作（%10），取出最后一位数字 `y = x % 10`
- 将最后一位数字加到取出数的末尾，`revertedNumber = revertedNumber * 10  + y`
- 每取一个最低位数字，x本身需要除以10，（考虑到javascript精度问题，这里需要先将本身*10，然后/10）
- 判断`X`是不是小于`revertedNumber`，当`x`小于的时候，说明反转数字过半或已经过半了
- 最有，判断奇偶数情况，如果为偶数`x===revertedNumber`；如果是奇数的话，最中间的数字就在`revertedNumber`的最低位上，将它除以10以后就应该和`X`相等

实现代码

```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
let isPalindrome = function (x) {
  let revertedNumber = 0
  // 特殊情况
  // 1、如果输入数字为负数，那么肯定不是回文
  // 2、同样的，如果输入数字末尾是0，那么为了使数字为回文，那么第一位页数也应该是回文，那么满足这个条件的只有0
  if (x < 0 || (x % 10 === 0 && x !== 0)) {
    return false
  }

  // 1、反转后半部分数字
  //    对于数字12321，如果执行12321 % 10 , 我们将得到最后一位数字，如果要得到倒数第二位数字，我们可以先通过把最后一位数字从12321中移除(12321/10=1232),在求出上一步的数的余数(1232%10=2)
  //    这样就可以得到倒数第二位数字，如果我们把最后一位数字乘以10，在加上倒数第二位数字(1*10+2=12),就得到我们想要的反转后的数字，如果继续这个过程，就会得到更多的反转数字
  // 2、判断反转数字达到原始数组的一半
  //    我们将原始数字除以10，反转数字乘以10，所有当原始数字小于反转数字的时候，就意味着我们已经处理了一半位数的数字了（考虑到js精度问题，需要将/10的数事先*10）

  while (x > revertedNumber) {
    revertedNumber = revertedNumber * 10 + x % 10
    x = (x - x % 10) / 10
  }

  // 当数字长度为奇数时，我们可以通过revertedNumber/10 去出去中位数
  // 例如，当输入为12321时，在while循环的末尾我们可以得到x = 12，revertedNumber = 123，由于处于中位数的数字不影响回文(它总是和自己相等)，所有我们可以简单的将其去除
  return x === revertedNumber || x === (revertedNumber - revertedNumber % 10) / 10
};
```

